// ─────────────────────────────────────────────
// 1. 입력 처리
// ─────────────────────────────────────────────
const fs = require("fs");
const input = fs.readFileSync(0, "utf8").trim().split("\n");

const N = Number(input[0]); // 사람 수 (짝수)
const S = input
  .slice(1)
  .map((line) => line.split(" ").map(Number)); // 능력치 배열 S[i][j]

// 방문 배열: true면 '스타트 팀', false면 '링크 팀'
const visited = new Array(N).fill(false);

// 두 팀 능력치 차이의 최솟값
let answer = Infinity;

// ─────────────────────────────────────────────
// 2. 능력치 차이 계산 함수
// ─────────────────────────────────────────────
//
// 현재 visited 배열 상태대로
// 스타트 팀, 링크 팀의 능력치를 각각 계산해
// 두 값의 차이를 반환한다.
//
function calcDiff() {
  let start = 0; // 스타트 팀 능력치 합
  let link = 0;  // 링크 팀 능력치 합

  // i < j 인 쌍만 보면서 팀에 따라 능력치를 더한다.
  for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
      // 둘 다 스타트 팀
      if (visited[i] && visited[j]) {
        start += S[i][j] + S[j][i];
      }
      // 둘 다 링크 팀
      else if (!visited[i] && !visited[j]) {
        link += S[i][j] + S[j][i];
      }
    }
  }

  return Math.abs(start - link);
}

// ─────────────────────────────────────────────
// 3. 백트래킹으로 팀 나누기
// ─────────────────────────────────────────────
//
// dfs(idx, cnt)
//  - idx: 현재 고려 중인 사람 번호 (0 ~ N-1)
//  - cnt: 지금까지 스타트 팀에 넣은 사람 수
//
// 목표: 스타트 팀에 정확히 N/2 명을 고르는 모든 조합 탐색
//
function dfs(idx, cnt) {
  // 스타트 팀이 N/2명이 되면 능력치 차이를 계산
  if (cnt === N / 2) {
    const diff = calcDiff();
    if (diff < answer) answer = diff;
    return;
  }

  // 남은 사람 모두를 스타트 팀에 넣어도 N/2를 못 채우는 경우 가지치기
  if (idx >= N) return;

  // 현재 인덱스부터 N까지 순회하면서
  // 스타트 팀에 포함시킬 사람을 선택
  for (let i = idx; i < N; i++) {
    // 이미 스타트 팀에 포함된 사람은 건너뛸 필요는 없지만
    // visited로 분기하므로 중복 선택은 자연스럽게 방지된다.
    visited[i] = true;         // i번 사람을 스타트 팀에 넣는다
    dfs(i + 1, cnt + 1);       // 다음 사람 선택하러 이동
    visited[i] = false;        // 백트래킹: 다시 원상복구
  }
}

// ─────────────────────────────────────────────
// 4. 대칭 경우 제거 최적화
// ─────────────────────────────────────────────
//
// 팀을 나눌 때, 사람 0이 스타트 팀에 있든 링크 팀에 있든
// 두 경우는 서로 대칭이므로 한 번만 계산해도 된다.
// → 0번 사람을 스타트 팀에 고정해놓고 시작하면
//   탐색할 경우의 수를 절반으로 줄일 수 있다.
//
visited[0] = true;     // 0번 사람을 스타트 팀에 고정
dfs(1, 1);             // 1번 인덱스부터 시작, 현재 스타트 팀 인원은 1명

// ─────────────────────────────────────────────
// 5. 결과 출력
// ─────────────────────────────────────────────
console.log(answer.toString());