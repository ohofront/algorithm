// ─────────────────────────────────────────────
// 1. 입력 처리
// ─────────────────────────────────────────────
const fs = require("fs");
const n = Number(fs.readFileSync(0, "utf8").trim());

// ─────────────────────────────────────────────
// 2. 재귀 피보나치 (fib) 호출 횟수 카운트
// ─────────────────────────────────────────────
//
// 문제에서 제시한 코드:
//
// fib(n) {
//   if (n == 1 or n == 2)
//     return 1;                    ← 이 부분이 몇 번 실행되는지 카운트
//   else return fib(n - 1) + fib(n - 2);
// }
//
// 위 코드에서 if문이 참이 되는 순간(= n이 1 또는 2인 순간)이
// 바로 재귀식의 '종료 조건' 코드가 실행되는 횟수이다.
// 이 횟수를 재귀로 직접 세보자.
//
let recursiveCount = 0; // 코드1 실행 횟수

function fibRecursive(x) {
  if (x === 1 || x === 2) {
    // 종료 조건에 도달할 때마다 1 증가
    recursiveCount++;
    return 1;
  }
  return fibRecursive(x - 1) + fibRecursive(x - 2);
}

// 실제로 값은 필요 없지만, 재귀 호출을 트리 구조로 모두 탐색해야
// recursiveCount가 정확히 계산되므로 한 번 호출해준다.
fibRecursive(n);

// ─────────────────────────────────────────────
// 3. 동적 계획법 피보나치 (dp)에서의 연산 횟수 카운트
// ─────────────────────────────────────────────
//
// 문제에서 제시한 dp 코드:
//
// fib(n) {
//   f[1] <- 1
//   f[2] <- 1
//   for i <- 3 to n
//     f[i] <- f[i - 1] + f[i - 2]   ← 이 줄이 몇 번 실행되는지 카운트
//   return f[n]
// }
//
// for 문 안의 대입 연산이 실행되는 횟수 = (n - 2) 번
// (i = 3, 4, ..., n 으로 총 n-2번)
//
// 하지만 이해를 위해 실제로 dp를 수행하면서 세어보자.
//
let dpCount = 0; // 코드2 실행 횟수

function fibDP(x) {
  const f = new Array(x + 1).fill(0);
  f[1] = 1;
  f[2] = 1;

  for (let i = 3; i <= x; i++) {
    f[i] = f[i - 1] + f[i - 2];
    dpCount++; // f[i]를 계산할 때마다 1 증가
  }
  return f[x];
}

fibDP(n);

// ─────────────────────────────────────────────
// 4. 결과 출력
// ─────────────────────────────────────────────
//
// 첫 번째 값: 재귀 방식에서 코드1이 실행된 횟수
// 두 번째 값: DP 방식에서 코드2가 실행된 횟수
//
console.log(String(recursiveCount), String(dpCount));